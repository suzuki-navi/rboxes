#!/bin/bash

script_dir="$(cd $(dirname "${BASH_SOURCE[0]}") && pwd)"

source "$script_dir/parse_args.sh"

calc_file_content_hash() {
    local file="$1"
    sha256sum "$file" | awk '{print $1}' | cut -b-8
}

is_binary_file() {
    file="$1"

    # 1. Check if file contains control characters (0x00-0x1F) except newline (0x0A)
    if LC_ALL=C grep -qP '[\x00-\x09\x0B-\x1F]' "$file"; then
        return 0  # Treat as binary
    fi

    # 2. Check if file doesn't end with newline
    if [ -s "$file" ]; then
        last_char=$(tail -c1 "$file")
        if [ "$last_char" != "" ] && [ "$last_char" != $'\n' ]; then
            return 0  # Treat as binary
        fi
    fi

    return 1  # Treat as text
}

make_self_extract_script() {
    local target_dir="$1"
    local use_compression="$2"
    cd "$target_dir" || exit 1

    # Generate header with documentation
    echo "#!/bin/bash"
    echo
    echo "# Self-extracting script generated by rselfpack"
    echo "#"
    echo "# USAGE:"
    echo "#   bash ./[this_script_name]                   Extract files to current directory"
    echo "#   bash ./[this_script_name] [target_dir]      Extract files to specified directory"
    echo "#"
    echo "# FILES TO BE EXTRACTED:"
    find . -type f | LC_ALL=C sort | while read -r file_path; do
        file_path="${file_path#./}"
        printf "#   %s\n" "$file_path"
    done
    echo

    cat << 'EOF'
# Parse target directory argument
target_directory="."
if [ $# -eq 1 ]; then
    target_directory="$1"
    if [ ! -d "$target_directory" ]; then
        mkdir -p "$target_directory" || {
            echo "Error: Cannot create directory '$target_directory'" >&2
            exit 1
        }
    fi
elif [ $# -gt 1 ]; then
    echo "Error: Too many arguments. Usage: $0 [target_directory]" >&2
    exit 1
fi

# Change to target directory
cd "$target_directory" || {
    echo "Error: Cannot change to directory '$target_directory'" >&2
    exit 1
}

EOF
    
    find . -type f | LC_ALL=C sort | while read -r file_path; do
        file_path="${file_path#./}"

        if [ "$(dirname "$file_path")" != "." ]; then
            printf 'mkdir -p "%s"\n' "$(dirname "$file_path")"
        fi

        file_hash=$(calc_file_content_hash "$file_path")
        if [ ! -s "$file_path" ]; then
            # Empty file - create empty file
            printf 'echo "" > "%s"\n' "$file_path"
        elif is_binary_file "$file_path"; then
            # Binary file - encode with base64 and output
            printf 'base64 -d > "%s" << END_OF_%s\n' "$file_path" $file_hash
            base64 "$file_path"
            echo "END_OF_$file_hash"
        else
            # Text file - output as plain text
            printf 'cat > "%s" << '\''END_OF_%s'\''\n' "$file_path" $file_hash
            cat "$file_path"
            echo "END_OF_$file_hash"
        fi
        echo
    done | (
        temp_file=$(mktemp)
        cat > "$temp_file"
        file_hash=$(calc_file_content_hash "$temp_file")
        
        if [ "$use_compression" = "true" ]; then
            printf 'base64 -d << END_OF_%s | gzip -d | bash\n' $file_hash
            cat "$temp_file" | gzip | base64
        else
            printf 'cat << END_OF_%s | bash\n' $file_hash
            cat "$temp_file"
        fi
        
        printf 'END_OF_%s\n' $file_hash
        rm "$temp_file"
    )
}

make_self_extract_script "$target_path" "$use_compression"